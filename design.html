<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gothic Cathedral Maze</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            image-rendering: pixelated;
        }
        canvas {
            background-color: #0a0000;
            border: 4px solid #3a0a0a;
            box-shadow: 0 0 20px #500000;
            image-rendering: pixelated;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            color: #ff9090;
            background-color: rgba(40, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 600px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="500" height="400"></canvas>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Set up pixel scaling
        const PIXEL_SIZE = 2;
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;
        
        // Scale up the canvas for display
        canvas.style.width = `${GAME_WIDTH * PIXEL_SIZE}px`;
        canvas.style.height = `${GAME_HEIGHT * PIXEL_SIZE}px`;
        
        // Disable image smoothing for crisp pixels
        ctx.imageSmoothingEnabled = false;

        let player, light, detected, gameOver;
        const speed = 2;
        let lightSpeed = 0.5;
        let angle = 0;
        let stopLight = false;
        let keys = {};
        let frameCount = 0;
        
        const COLORS = {
            background: "#220000",
            floor: "#3a0a0a",
            floorPattern: "#2a0505",
            walls: "#4a1010",
            wallsHighlight: "#5a2020",
            player: "#ffcc00",
            playerShadow: "#aa7700",
            light: "#ffaa77",
            lightGlow: "#ff5500",
            gameOverBg: "#000000",
            gameOverText: "#ff3333",
            candleLight: "#ffaa55",
            stainedGlass: ["#ff0000", "#aa00aa", "#ffaa00", "#ff00aa"]
        };
        
        let walls = [];
        let pillars = [];
        let candles = [];
        let floorTiles = [];
        let stainedGlass = [];

        function createCathedralElements() {
            // Create outer walls (border around the screen)
            walls = [
                {x: 0, y: 0, width: GAME_WIDTH, height: 20}, // Top wall
                {x: 0, y: GAME_HEIGHT - 20, width: GAME_WIDTH, height: 20}, // Bottom wall
                {x: 0, y: 0, width: 20, height: GAME_HEIGHT}, // Left wall
                {x: GAME_WIDTH - 20, y: 0, width: 20, height: GAME_HEIGHT} // Right wall
            ];
            
            // Create maze walls
            // Horizontal walls
            walls.push({x: 40, y: 40, width: 80, height: 10});
            walls.push({x: 160, y: 40, width: 120, height: 10});
            walls.push({x: 40, y: 80, width: 40, height: 10});
            walls.push({x: 120, y: 80, width: 80, height: 10});
            walls.push({x: 240, y: 80, width: 40, height: 10});
            walls.push({x: 80, y: 120, width: 80, height: 10});
            walls.push({x: 200, y: 120, width: 80, height: 10});
            walls.push({x: 40, y: 160, width: 120, height: 10});
            walls.push({x: 200, y: 160, width: 40, height: 10});
            walls.push({x: 80, y: 200, width: 160, height: 10});
            
            // Vertical walls
            walls.push({x: 80, y: 40, width: 10, height: 40});
            walls.push({x: 160, y: 56, width: 10, height: 64});
            walls.push({x: 200, y: 40, width: 10, height: 40});
            walls.push({x: 240, y: 96, width: 10, height: 64});
            walls.push({x: 40, y: 96, width: 10, height: 64});
            walls.push({x: 120, y: 96, width: 10, height: 64});
            walls.push({x: 80, y: 136, width: 10, height: 64});
            walls.push({x: 200, y: 136, width: 10, height: 24});
            walls.push({x: 160, y: 160, width: 10, height: 40});
            
            // Create pillars at intersections
            pillars = [
                {x: 80, y: 80, size: 10},
                {x: 160, y: 80, size: 10},
                {x: 200, y: 80, size: 10},
                {x: 240, y: 80, size: 10},
                {x: 80, y: 120, size: 10},
                {x: 160, y: 120, size: 10},
                {x: 200, y: 120, size: 10},
                {x: 80, y: 160, size: 10},
                {x: 160, y: 160, size: 10},
                {x: 200, y: 160, size: 10}
            ];
            
            // Create candles throughout the maze
            candles = [
                {x: 30, y: 30, size: 4}, // Top left
                {x: GAME_WIDTH - 34, y: 30, size: 4}, // Top right
                {x: 30, y: GAME_HEIGHT - 34, size: 4}, // Bottom left
                {x: GAME_WIDTH - 34, y: GAME_HEIGHT - 34, size: 4}, // Bottom right
                {x: 60, y: 60, size: 4}, // Maze candles
                {x: 140, y: 60, size: 4},
                {x: 220, y: 60, size: 4},
                {x: 60, y: 100, size: 4},
                {x: 140, y: 100, size: 4},
                {x: 220, y: 100, size: 4},
                {x: 60, y: 140, size: 4},
                {x: 140, y: 140, size: 4},
                {x: 220, y: 140, size: 4},
                {x: 60, y: 180, size: 4},
                {x: 140, y: 180, size: 4},
                {x: 220, y: 180, size: 4},
                {x: GAME_WIDTH/2, y: GAME_HEIGHT/2, size: 4} // Center
            ];
            
            // Create floor tiles
            for (let y = 20; y < GAME_HEIGHT - 20; y += 20) {
                for (let x = 20; x < GAME_WIDTH - 20; x += 20) {
                    floorTiles.push({
                        x: x,
                        y: y,
                        size: 20,
                    });
                }
            }
            
            //Create stained glass window at the top
            for (let i = 0; i < 8; i++) {
                stainedGlass.push({
                    x: GAME_WIDTH/2 - 40 + i*10,
                    y: 5,
                    size: 10,
                    color: COLORS.stainedGlass[i % COLORS.stainedGlass.length]
                });
            }
        } 

        function resetGame() {
            player = { 
                x: 30, 
                y: 30, 
                size: 8,
                direction: 0, // 0: down, 1: left, 2: right, 3: up
                animFrame: 0,
                animCounter: 0
            };
            
            light = { 
                x: Math.floor(GAME_WIDTH / 2), 
                y: Math.floor(GAME_HEIGHT / 2), 
                size: 35,
                intensity: 1,
                pathIndex: 0,
                path: [
                    {x: GAME_WIDTH/2, y: GAME_HEIGHT/2},
                    {x: 60, y: 60},
                    {x: 140, y: 60},
                    {x: 220, y: 60},
                    {x: 220, y: 140},
                    {x: 140, y: 140},
                    {x: 60, y: 140},
                    {x: 60, y: 220},
                    {x: 140, y: 220},
                    {x: 220, y: 220}
                ],
                speed: 0.5
            };
            
            detected = false;
            gameOver = false;
            angle = 0;
            
            walls = [];
            pillars = [];
            candles = [];
            floorTiles = [];
            stainedGlass = [];
            createCathedralElements();
        }

        document.addEventListener("keydown", (e) => {
            keys[e.key] = true;
            if (e.key === "r" || e.key === "R") resetGame(); // Restart game
        });

        document.addEventListener("keyup", (e) => keys[e.key] = false);

        function movePlayer() {
            if (gameOver) return;
            
            // Animation counter
            player.animCounter++;
            if (player.animCounter >= 10) {
                player.animFrame = (player.animFrame + 1) % 2;
                player.animCounter = 0;
            }
            
            let moved = false;
            let newX = player.x;
            let newY = player.y;
            
            // Move player with pixel-perfect positioning
            if (keys["ArrowUp"]) {
                newY -= speed;
                player.direction = 3;
                moved = true;
            }
            if (keys["ArrowDown"]) {
                newY += speed;
                player.direction = 0;
                moved = true;
            }
            if (keys["ArrowLeft"]) {
                newX -= speed;
                player.direction = 1;
                moved = true;
            }
            if (keys["ArrowRight"]) {
                newX += speed;
                player.direction = 2;
                moved = true;
            }
            
            // Check collision with walls and pillars
            let collision = false;
            
            // Wall collision
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                if (newX < wall.x + wall.width && 
                    newX + player.size > wall.x && 
                    newY < wall.y + wall.height && 
                    newY + player.size > wall.y) {
                    collision = true;
                    break;
                }
            }
            
            // Pillar collision
            if (!collision) {
                for (let i = 0; i < pillars.length; i++) {
                    const pillar = pillars[i];
                    if (newX < pillar.x + pillar.size && 
                        newX + player.size > pillar.x && 
                        newY < pillar.y + pillar.size && 
                        newY + player.size > pillar.y) {
                        collision = true;
                        break;
                    }
                }
            }
            
            // Update position if no collision
            if (!collision) {
                player.x = newX;
                player.y = newY;
            }
            
            // Only animate if moving
            if (!moved) {
                player.animFrame = 0;
                player.animCounter = 0;
            }
        }

        function moveLight() {
            if (gameOver) return;
            
            // Move light along predefined path
            const currentTarget = light.path[light.pathIndex];
            const dx = currentTarget.x - light.x;
            const dy = currentTarget.y - light.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 2) {
                // Move to next point in path
                light.pathIndex = (light.pathIndex + 1) % light.path.length;
            } else {
                // Move towards current target
                light.x += (dx / distance) * light.speed;
                light.y += (dy / distance) * light.speed;
            }
            
            // Check if player is caught in light
            const playerDx = player.x + player.size/2 - light.x;
            const playerDy = player.y + player.size/2 - light.y;
            const playerDistance = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
            detected = playerDistance < light.size * 0.7;

            if (detected) {
                gameOver = true; // End game when caught
            }
            
            // Light intensity variation
            light.intensity = 2 + Math.sin(frameCount * 0.1) * 0.1;
        }

        function drawPixelRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }

        function drawCathedral() {
            // Draw background
            drawPixelRect(0, 0, GAME_WIDTH, GAME_HEIGHT, COLORS.background);
            
            // Draw floor tiles
            for (let i = 0; i < floorTiles.length; i++) {
                const tile = floorTiles[i];
                drawPixelRect(tile.x, tile.y, tile.size, tile.size, 
                             tile.type === 0 ? COLORS.floor : COLORS.floorPattern);
            }
            
            // Draw stained glass window
            for (let i = 0; i < stainedGlass.length; i++) {
                const glass = stainedGlass[i];
                drawPixelRect(glass.x, glass.y, glass.size, glass.size, glass.color);
            }
            
            // Draw walls
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                drawPixelRect(wall.x, wall.y, wall.width, wall.height, COLORS.walls);
                
                // Wall pattern
                if (wall.width > wall.height) {
                    // Horizontal wall
                    for (let x = wall.x + 5; x < wall.x + wall.width - 5; x += 10) {
                        drawPixelRect(x, wall.y + 5, 5, wall.height - 10, COLORS.wallsHighlight);
                    }
                } else {
                    // Vertical wall
                    for (let y = wall.y + 5; y < wall.y + wall.height - 5; y += 10) {
                        drawPixelRect(wall.x + 5, y, wall.width - 10, 5, COLORS.wallsHighlight);
                    }
                }
            }
            
            // Draw pillars
            for (let i = 0; i < pillars.length; i++) {
                const pillar = pillars[i];
                drawPixelRect(pillar.x, pillar.y, pillar.size, pillar.size, COLORS.walls);
                // Pillar highlight
                drawPixelRect(pillar.x + 3, pillar.y + 3, pillar.size - 6, pillar.size - 6, COLORS.wallsHighlight);
            }
        }

        function drawCandles() {
            for (let i = 0; i < candles.length; i++) {
                const candle = candles[i];
                
                // Candle base
                drawPixelRect(candle.x, candle.y, candle.size, candle.size * 2, "#aa5533");
                
                // Candle flame with flickering
                const flicker = Math.sin(frameCount * 0.2 + i) * 2;
                const flameSize = 3 + (frameCount % 4 < 2 ? 1 : 0);
                
                // Draw candle light glow
                const candleIntensity = 0.5 + Math.sin(frameCount * 0.1 + i) * 0.1;
                for (let y = candle.y - 5; y < candle.y + 10; y++) {
                    for (let x = candle.x - 5; x < candle.x + candle.size + 5; x++) {
                        if (x >= 0 && x < GAME_WIDTH && y >= 0 && y < GAME_HEIGHT) {
                            const dx = x - (candle.x + candle.size/2);
                            const dy = y - candle.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 10) {
                                const opacity = (1 - distance / 10) * candleIntensity * 0.3;
                                ctx.fillStyle = `rgba(255, 170, 85, ${opacity})`;
                                ctx.fillRect(x, y, 1, 1);
                            }
                        }
                    }
                }
                
                // Candle flame
                drawPixelRect(candle.x + candle.size/2 - 1, candle.y - flameSize + flicker, 2, flameSize, "#ffff77");
            }
        }

        function drawLight() {
            const lightX = Math.floor(light.x - light.size/2);
            const lightY = Math.floor(light.y - light.size/2);
            const lightSize = Math.floor(light.size);
            
            // Draw light source
            drawPixelRect(light.x - 3, light.y - 3, 6, 6, COLORS.lightGlow);
            
            // Draw light area with pixel-perfect edges
            for (let y = lightY; y < lightY + lightSize; y++) {
                for (let x = lightX; x < lightX + lightSize; x++) {
                    if (x >= 0 && x < GAME_WIDTH && y >= 0 && y < GAME_HEIGHT) {
                        const dx = x - light.x;
                        const dy = y - light.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < lightSize/2) {
                            // Calculate opacity based on distance from center
                            const opacity = (1 - (distance / (lightSize/2))) * light.intensity;
                            ctx.fillStyle = `rgba(255, 170, 119, ${opacity * 0.5})`;
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }
        }

        function drawPlayer() {
    // Draw player shadow
    drawPixelRect(player.x, player.y + player.size - 2, player.size, 2, COLORS.playerShadow);
    
    // Ghost body base
    drawPixelRect(player.x + 1, player.y, player.size - 2, player.size, COLORS.player);
    
    // bottom
    if (player.direction === 0) { // Down
        drawPixelRect(player.x, player.y + player.size - 3, 1, 2, COLORS.player);
        drawPixelRect(player.x + player.size - 1, player.y + player.size - 3, 1, 2, COLORS.player);
    }
    
    // Ghost head shape
    drawPixelRect(player.x + 2, player.y, player.size - 4, 2, COLORS.player);
    
    // Eyes based on direction
    if (player.direction === 0) { // Down
        // Wide, spooky eyes
        drawPixelRect(player.x + 1, player.y + 2, 2, 1, "#FFFFFF");
        drawPixelRect(player.x + player.size - 3, player.y + 2, 2, 1, "#FFFFFF");
    } else if (player.direction === 1) { // Left
        drawPixelRect(player.x + 1, player.y + 2, 2, 1, "#FFFFFF");
    } else if (player.direction === 2) { // Right
        drawPixelRect(player.x + player.size - 3, player.y + 2, 2, 1, "#FFFFFF");
    } else if (player.direction === 3) { // Up
        // Tiny, mysterious eyes
        drawPixelRect(player.x + 2, player.y + 2, 1, 1, "#FFFFFF");
        drawPixelRect(player.x + player.size - 3, player.y + 2, 1, 1, "#FFFFFF");
    }
    
    // Subtle animation/movement
    if (player.animFrame === 1) {
        // Slight body wobble
        if (player.direction === 0) { // Down
            drawPixelRect(player.x, player.y + player.size - 1, 1, 1, COLORS.player);
            drawPixelRect(player.x + player.size - 1, player.y + player.size - 1, 1, 1, COLORS.player);
        } else if (player.direction === 1) { // Left
            drawPixelRect(player.x, player.y + player.size - 1, 1, 1, COLORS.player);
        } else if (player.direction === 2) { // Right
            drawPixelRect(player.x + player.size - 1, player.y + player.size - 1, 1, 1, COLORS.player);
        } else if (player.direction === 3) { // Up
            drawPixelRect(player.x, player.y + player.size - 1, 1, 1, COLORS.player);
            drawPixelRect(player.x + player.size - 1, player.y + player.size - 1, 1, 1, COLORS.player);
        }
    }
}

        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Draw cathedral background
            drawCathedral();
            
            // Draw candles with light effect
            drawCandles();
            
            // Draw light effect
            drawLight();
            
            // Draw player
            drawPlayer();
            
            // Draw detection effect
            if (detected) {
                ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }
            
            // Show game over message
            if (gameOver) {
                const paddingX = 5; // Padding for width
                const paddingY = 2; // Reduced padding for height

                // Adjust the rectangle dimensions to include padding
                const rectWidth = 120 + paddingX * 2;
                const rectHeight = 40 + paddingY * 2;
                const rectX = GAME_WIDTH / 2 - rectWidth / 2;
                const rectY = GAME_HEIGHT / 2 - rectHeight / 2;

                drawPixelRect(rectX, rectY, rectWidth, rectHeight, COLORS.gameOverBg);

                // Adjust text positions to fit within the rectangle
                ctx.fillStyle = COLORS.gameOverText;
                ctx.font = "10px Courier New";
                ctx.textAlign = "center";

                const textY = GAME_HEIGHT / 2 - rectHeight / 4; // Adjusted text position for reduced top padding
                ctx.fillText("CAUGHT!", GAME_WIDTH / 2, textY + 6);
                ctx.fillText("PRESS 'R' TO RESTART", GAME_WIDTH / 2, textY + 24 );
            }
        }

        function gameLoop() {
            frameCount++;
            movePlayer();
            moveLight();
            draw();
            requestAnimationFrame(gameLoop);
        }

        resetGame();
        createCathedralElements();
        gameLoop();
    </script>
</body>
</html>